import time
from twilio.rest import Client
from twilio.base.exceptions import TwilioRestException
import os
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from difflib import SequenceMatcher
ACCOUNT_SID = 'YOUR SID ACCOUNT ID'
AUTH_TOKEN = 'YOUR AUTH_TOKEN'
FROM_PHONE = 'TWILIO NO'
TO_PHONE = 'YOUR PHONE NO'
files_to_monitor = [
    r"GIVE FILE PATH SHOULD MONITOR "
]

previous_contents = {}

def track_changes(old_content, new_content):
    """Detect changes between old and new content."""
    changes = []
    matcher = SequenceMatcher(None, old_content.split(), new_content.split())
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if tag == 'replace':
            changes.append(f"Replaced '{' '.join(old_content.split()[i1:i2])}' with '{' '.join(new_content.split()[j1:j2])}'")
        elif tag == 'delete':
            changes.append(f"Deleted '{' '.join(old_content.split()[i1:i2])}'")
        elif tag == 'insert':
            changes.append(f"Inserted '{' '.join(new_content.split()[j1:j2])}'")
    return changes

def send_sms_notification(file_path, changes):
    """Send SMS with changes detected in the file."""
    try:
        client = Client(ACCOUNT_SID, AUTH_TOKEN)
        change_details = "\n".join(changes)
        message_body = f"Alert: The file {file_path} has been modified.\nChanges:\n{change_details}"

        message = client.messages.create(
            from_=FROM_PHONE,
            body=message_body,
            to=TO_PHONE
        )

        print(f"SMS sent for file change: {file_path} with SID: {message.sid}")
        message_status = client.messages(message.sid).fetch()
        print(f"Message Status: {message_status.status}")

    except TwilioRestException as e:
        print(f"Twilio error: {e}")
    except Exception as e:
        print(f"Error sending SMS: {e}")

class FileChangeHandler(FileSystemEventHandler):
    def on_modified(self, event):
        global previous_contents
        normalized_path = os.path.normpath(event.src_path)
        for file_path in files_to_monitor:
            if os.path.normpath(file_path) == normalized_path:
                print(f"File {file_path} has been modified.")
                try:
                    with open(file_path, 'r', errors='ignore') as file:
                        new_content = file.read()

                    if file_path in previous_contents:
                        old_content = previous_contents[file_path]
                        changes = track_changes(old_content, new_content)
                        if changes:
                            send_sms_notification(file_path, changes)
                    else:
                        print(f"Initial content loaded for {file_path}. No changes to compare.")

                    previous_contents[file_path] = new_content

                except Exception as e:
                    print(f"Error reading file: {e}")

def monitor_files(file_paths):
    global previous_contents
    for file_path in file_paths:
        if not os.path.exists(file_path):
            print(f"Error: The file {file_path} does not exist.")
            continue
        try:
            with open(file_path, 'r', errors='ignore') as file:
                previous_contents[file_path] = file.read()
        except Exception as e:
            print(f"Error reading file {file_path}: {e}")

    event_handler = FileChangeHandler()
    observer = Observer()
    monitored_dirs = set()
    for file_path in file_paths:
        directory = os.path.dirname(file_path)
        if directory not in monitored_dirs:
            observer.schedule(event_handler, directory, recursive=False)
            monitored_dirs.add(directory)

    print("Monitoring started on the following files:")
    for f in file_paths:
        print(f"- {f}")

    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("Monitoring stopped.")
    observer.join()

if __name__ == "__main__":
    monitor_files(files_to_monitor)
